01.Lexical & Syntax

## 변수(variable)와 값(value)

```
int price = 1000; // java, c, c++
count = 10      // python, javascript
```

 보통, 우리는 프로그래밍 코드에서 다룰 데이터를 정의하기 위해 위와 비슷한 코드로 데이터가 가진 의미가 바로 들어날 수 있는 이름으로 지은 변수에 그 데이터(값)을 대입하게 된다. 프로그래밍 언어에 따라 위의 코드가 어휘적으로 표현식(Expression)이 될 수 있고 절(Clause) 또는 구문(Statement)이 될 수 있다. 변수 앞에 데이터의 타입을 지정해야 하기도 하고 하지 않아도 되는 프로그래밍 언어도 있다. 뿐만 아니라, 내부적으로 저장하고 있는 형태도 다를 수 있다. 값 자체를 스택에 저장할 수도 있고 힙 상의 객체 안에 저장될 수도 있다. 하지만, 작성하고 있는 프로그래밍 언어의 이와 같은 개별적 특성들을 잘 몰라도 1000 또는 10이라는 값(Value)이 저장 공간(메모리) 어딘가에 저장되었고 price 또는 count라는 변수(Variable)로 다음 라인의 코드에서 사용할 수 있음을 우리는 확신한다.  

 변수에 대한 수학적 정의는 '임의의 값을 표현하는 기호' 이다. 우리가 price 또는 count를 변수라 부르는 것은 이 정의에 가깝다. 임의의 값은 메모리 어디에 저장된 값이다. 값 자체를 저장하던 객체 형태로 저장하던 상관 없다. 임의라는 의미는 우리가 의도한 알고리즘(로직)쯤 될 수 있다. 그리고 변할 수 있다. 중요한 것은 알고리즘 또는 특정 로직으로 변화된 값의 변화(상태)를 알려면 그 값에 기호(이름)을 붙혀 놓아야 한다는 점을 이해하고 납득해야 한다. 사실 변하는 것은 메모리 어떤 공간에 저장된 그 값이지만 우리는 그 변화를 코드에서 관리하기 위해 그 메모리 공간에 이름을 붙힌다. 그리고 그 이름을 통상적으로 변수라 부르는 것이다.
 
 그 공간은 메모리로 알다시피 1byte 단위로 개개의 메모리 주소에 매핑(할당)된다. 사실, 그 메모리 공간에 물리적으로 이름 따위는 붙힐 수는 없고 메모리 주소로 매핑되어야 한다. 따라서 변수라 불리는 그 이름은 원래 값이 저장되는 메모리 공간에 대한 심볼(Symbolic Name)이다. 따라서 우리는 프로그램 코드에서 메모리 주소 대신 이름으로 값을 쉽게 다룰 수 있다. 값 자체가 메모리 공간에 저장될 수 있는 프로그래밍 언어(원시 타입이 있는 프로그래밍 언어: C, C++, 자바)들은 컴파일 또는 실행 때에 실제 메모리 주소로 매핑된다. 객체로 값을 다루는 프로그래밍 언어(보통 원시 타입이 없는 언어: 파이썬, 자바스크립트 유사 객체, 자바 래퍼 클래스)에서는 객체를 참조할 수 있는 레퍼런스로 값을 다루어야 한다. 하지만 코드로만 보면 값 자체를 메모리에 저장하는 프로그래밍 언어들의 변수와 차이가 없다(메모리 주소 타입의 변수가 있는 C, C++ 논외). 변수 이름, 레퍼런스, 객체 그리고 객체 안의 값과의 매핑 관계는 프로그래밍 언어가 해결하고 우리는 값을 저장하는 변수처럼 사용하면 되기 때문이다. 컴파일 언어는 이 매핑 관계 구현이 어렵다. 이유는 객체가 실행(런타임)때 주로 생성되기 때문이다. 이 매핑 관계 구현을 프로그래밍 언어별로 다양하게 추상화하고 구현하지만 공통점은 스크립트 언어 즉, 인터프리터 기반의 프로그래밍 언어들인 것도 이 이유다.        
 
 스칼라는 JVM 기반의 컴파일 언어지만 자바의 래퍼 클래스를 확장시키고 원시 타입을 없앴다. 원시 타입이 존재하지 않으며 원시 타입의 값들은 모두 다 메소드가 있는 객체다. 여기까지는 앞에서도 언급했지만 파이썬, 자바 래퍼 클래스등 다른 언어에서도 볼 수 있고 현대 프로그래밍 언어에서 그리 낯설지도 않다. 하지만, 스칼라에서는 변수와 값의 개념이 조금 다르다. 어떤 객체를 참조하는 이름이 다른 객체로 그 참조를 변경할 수 있으면 그 이름을 변수(Variable)라 하고 정의 될 때 참조하던 객체를 바꾸지 못하는 이름을 값(value)이라 한다.
 
 쉽게 말해 변수(Variable)는 객체에 대한 참조를 바꿀 수 있으며 값(Value)은 참조를 바꿀 수 없다. 자바에서 final 키워드를 변수 앞에 붙히는 것과 유사해 보이지만 용어와 개념에서 차이가 있다. 스칼라는 문법적으로도 이 것을 더 분명히 하기 위해 참조를 바꿀 수 있는 이름과 바꿀 수 없는 이름에 각각 var와 val 키워드를 지정한다. 이 것도 자바스크립트의 let과 const와 유사하다. 하지만 키워드가 가지는 의미뿐만 아니라 변수와 값에 대한 본질적인 전산/수학적 개념은 비교했던 다른 프로그래밍 언어들에 비해 훨씬 더 명확하다. 타 패러다임 언어들에 비해 수학적 기반과 원리를 더 가까이 하고 있는 함수형 언어들에서 이런 개념과 용어 정의를 더 선호한다. 하지만, 우리가 프로그래밍에서 통상적으로 하듯 스칼라에서도 값이나 객체에 붙혀진 이름을 변수라 통칭하고 단지 구분을 위해 var 변수, val 변수 정도로 부르기도 하니 변수에 대한 통상적인 이해를 우리가 스칼라에서 굳이 바꿀 필요는 없어 보인다. 하지만, 알고는 있어야 한다.


[예제: 01/ex01.sc]

```scala
val i = 10;
i = 20;     
```
 i는 Int 타입의 객체를 참조한다. val로 지정했기 때문에 참조를 바꾸면 오류가 발생한다. 2번째 라인에서 'reassignment to val' 오류가 발생한다. 10이라는 값으로만 사용해야 한다.


[예제: 01/ex02.sc]
```scala
var i = 10;
println(i);

i = 20;
println(i);    
```
 예상하는 바, 에러가 없이 i가 10에서 20으로 변경(Mutated) 되었다. 설명했지만, 10을 저장하고 있는 Int 타입 객체에서 20을 저장하고 있는 Int 타입 객체로 참조가 변경된 것이지 Int 객체가 저장하고 있는 내용이 변경된 것은 아니다. 즉, Int 객체는 불변 객체다. REPL로 예제 스크립트를 실행해 보면 3번 라인이 '// mutated i' 라고 나오는데 참조가 변경되는 것이지 객체 내부가 변경되는 것이 아니다.

 사실, 스칼라의 변수들은 레퍼런스가 변경되는 것을 의미한다고 보아야 한다. 객체는 불변일 수 있고 아닐 수도 있기 때문에 객체 내부의 변경과 스칼라의 변수와는 상관 관계는 없다. 다만 다만 값이나 객체를 변경해야 한다면 내부가 변경되지 않는 불변 객체를 참조하고 변경된 새로운 불변 객체로 참조를 변경하는 것이 바람직 하다는 것이다. 사용중인 겍체가 예상할 수 없는 곳의 변경으로 인한 버그(spooky action at a distance)와 같은 유형을 피하기 위해서 이다. 예를 들면 공유된 변경 가능한 상태에서 접근을 동기화 해야하는 다중 스레드 프로그램에서 동기화를 제대로 하지 않으면 치명적이다. 동기화 작업은 어렵고 락킹이라는 꽤 비싼 테크닉을 써야한다. 불변객체를 사용하면 이런 문제를 쉽게 해결할 수 있다.
 
 다음 예제는 val 키워드를 사용할 때 오해하지 말아야 할 것이 하나 있다. 스칼라의 값은 참조를 바꾸지 못하는 것이지 참조하고 있는 객체가 불변이 아니라면 변경될 수 있다.

[예제: 01/ex03.sc]
```scala
val a:Array[String] = new Array(5);
a(0) = "hello";

println(a.mkString(","));   
```
 앞의 예제들과 달리 타입을 명시한 변수 a가 크기가 5인 Array 객체를 참조한다. 참조하는 배열 객체의 첫번째 요소를 String 객체를 참조하도록 하여 배열 객체안의 요소를 수정하였다. 마지막은 배열 객체를 문자열로 화면에 출력하기 위해 문자열로 만드는 메소드를 호출했다. 스칼라의 값은 초기화 후 참조를 변경하지 못하는 것이지 참조하는 객체의 불변여부에 따라 변경 가능하다. 따라서 스칼라의 값은 초기화를 반드시 해야 한다. 다음 예제는 오류다.

[예제: 01/ex04.sc]
```scala
val s;			// Wrong value declaration   
s = "hello";
println(s); 
```

 변수는 참조를 변경할 있기 때문에 var는 초기화가 필요없지만 최기화를 하지 않으면 val과 같은 문법 오류가 발생한다. 결론은 스칼라의 변수 선언은 var, val 모두 초기화 하여야 한다. 

 
 
 

## 타입
타입추론 언급

## 리터럴
null 대체도 여기서 언급


## 식별자


## 표현식
연산자 오버로딩도 여기서 언급


## 구문

for comprehension 언급